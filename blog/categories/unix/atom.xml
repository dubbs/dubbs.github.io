<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: unix | Kevin Warrington]]></title>
  <link href="http://dubbs.github.io/blog/categories/unix/atom.xml" rel="self"/>
  <link href="http://dubbs.github.io/"/>
  <updated>2014-03-08T15:17:44-06:00</updated>
  <id>http://dubbs.github.io/</id>
  <author>
    <name><![CDATA[Kevin Warrington]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Joining files on the command line]]></title>
    <link href="http://dubbs.github.io/blog/2013/10/15/joining-files-on-the-command-line/"/>
    <updated>2013-10-15T16:00:00-06:00</updated>
    <id>http://dubbs.github.io/blog/2013/10/15/joining-files-on-the-command-line</id>
    <content type="html"><![CDATA[<p>Here&rsquo;s an extremely easy way to join files in unix.  It uses the <code>()</code> subshell operator, which waits for the enclosed command to return before passing the result to standard out.</p>

<pre><code>(cat file1 file2)&gt; file3
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Unix Pipelines vs Redirection]]></title>
    <link href="http://dubbs.github.io/blog/2013/09/25/unix-pipelines-vs-redirection/"/>
    <updated>2013-09-25T20:05:00-06:00</updated>
    <id>http://dubbs.github.io/blog/2013/09/25/unix-pipelines-vs-redirection</id>
    <content type="html"><![CDATA[<p>Redirection is used to send data from standard streams to specific locations.</p>

<p>To send the standard output stream to a file, instead of the terminal:</p>

<pre><code>command1 &gt; outfile
command1 1&gt; outfile
</code></pre>

<p>Same as above, but instead send the standard error stream:</p>

<pre><code>command1 2&gt; outfile
</code></pre>

<p>To send standard output/error streams to a file, instead of the terminal:</p>

<pre><code>command1 &gt; outfile 2&gt;&amp;1
</code></pre>

<p>Output can also be disposed of using the null device:</p>

<pre><code>command1 &gt; /dev/null 2&gt;&amp;1
</code></pre>

<p>To use the contents of a file as the standard input stream to a command, instead of using keyboard input:</p>

<pre><code>command1 &lt; infile
</code></pre>

<p>Input can be read from one file and output to another:</p>

<pre><code>command1 &lt; infile &gt; outfile
</code></pre>

<p>The standard output of one command can also be used as the standard input to another using a temporary file:</p>

<pre><code>command1 &gt; file
command2 &lt; file
rm file
</code></pre>

<p>However, this is inefficient as the second command has to wait for the first to complete before proceeding.  Also, there is a chance that the temporary file will overwrite an already existing one.</p>

<p>Instead, it is more efficient to directly stream the output of one command into another via <code>pipes</code>:</p>

<pre><code>command1 | command2
</code></pre>

<p>Along with the standard out, you can also send standard error, notice that it appears before the pipe.</p>

<pre><code>command1 2&gt;&amp;1 | command2
</code></pre>

<p>It is also possible to direct the output of a command to standard out and an outfile using <code>tee</code>.</p>

<pre><code>command1 | tee outfile
</code></pre>

<p>Lastly, if you want to avoid overwriting files when redirecting, set noclobber:</p>

<pre><code>set -o noclobber
command1 &gt; existingfile
# -bash: existingfile: cannot overwrite existing file
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Moving on the Command Line]]></title>
    <link href="http://dubbs.github.io/blog/2013/09/17/moving-on-the-command-line/"/>
    <updated>2013-09-17T20:13:00-06:00</updated>
    <id>http://dubbs.github.io/blog/2013/09/17/moving-on-the-command-line</id>
    <content type="html"><![CDATA[<p>Moving along the command line will be a breeze, if you know the following shortcuts.</p>

<p><kbd>ctrl</kbd>+<kbd>a</kbd> &ndash; move to start of line<br/>
<kbd>ctrl</kbd>+<kbd>e</kbd> &ndash; move to end of line<br/>
<kbd>alt</kbd>+<kbd>b</kbd> &ndash; move backwards a word<br/>
<kbd>alt</kbd>+<kbd>f</kbd> &ndash; move forwards a word<br/>
<kbd>alt</kbd>+<kbd>del</kbd> &ndash; remove word<br/>
<kbd>ctrl</kbd>+<kbd>k</kbd> &ndash; remove to end of line</p>

<p>On Mac, make sure you setup the following config in <code>Terminal &gt; Preferences &gt; Keyboard</code>:</p>

<ul>
<li>use option as meta key is checked</li>
<li>option cursor left is set to \033b</li>
<li>option cursor right is set to \033f</li>
</ul>


<p>where \033 = <kbd>esc</kbd></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Working with Background Processes]]></title>
    <link href="http://dubbs.github.io/blog/2013/09/16/working-with-background-processes/"/>
    <updated>2013-09-16T21:33:00-06:00</updated>
    <id>http://dubbs.github.io/blog/2013/09/16/working-with-background-processes</id>
    <content type="html"><![CDATA[<p>For long running processes, rather than blocking your prompt, it&rsquo;s often useful to push commands to the background and complete other tasks.</p>

<p>To run a command in the background.</p>

<pre><code>&lt;command&gt; &amp;
</code></pre>

<p>To run a command in the background, detached from your console.  The process will not terminate on logout.  <code>nice</code> sets a lower priority.</p>

<pre><code>nohup nice &lt;command&gt; &amp;
</code></pre>

<p>List all background processes</p>

<pre><code>jobs
</code></pre>

<p>To send currently running command to background, first stop the process, <code>Ctrl-z</code>.</p>

<pre><code>bg
</code></pre>

<p>To bring a background process to the foreground</p>

<pre><code>fg
fg %1
</code></pre>

<p>To destroy a background process</p>

<pre><code>kill %1 
kill -9 %1  
kill &lt;pid&gt;
</code></pre>

<p>To receive an email notification when a background process finishes</p>

<pre><code>&lt;command&gt; | tee command.log | mailx -s 'PROCESS COMPLETE' test@example.com &amp;
</code></pre>

<p>To run a set of jobs when cpu levels permit, use batch.  <kbd>ctrl</kbd>+<kbd>d</kbd> to end input.</p>

<pre><code>user@example.com &gt; ~/.forward
batch -m
command1
command2
command3
</code></pre>

<p>You can list batch jobs and kill using the id</p>

<pre><code>at -l
at -r id
</code></pre>
]]></content>
  </entry>
  
</feed>
